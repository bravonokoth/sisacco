import 'package:flutter/foundation.dart';
import '../services/supabase_service.dart';
import '../models/account.dart';

class AccountProvider with ChangeNotifier {
  final SupabaseService _supabaseService = SupabaseService();
  
  List<Account> _accounts = [];
  bool _isLoading = false;
  String? _errorMessage;

  List<Account> get accounts => _accounts;
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;

  double get totalBalance {
    return _accounts.fold(0.0, (sum, account) => sum + account.balance);
  }

  double get totalAssets {
    return _accounts
        .where((account) => account.balance > 0)
        .fold(0.0, (sum, account) => sum + account.balance);
  }

  double get totalLiabilities {
    return _accounts
        .where((account) => account.balance < 0)
        .fold(0.0, (sum, account) => sum + account.balance.abs());
  }

  Future<void> loadUserAccounts(String userId) async {
    _setLoading(true);
    _clearError();

    try {
      _accounts = await _supabaseService.getUserAccounts(userId);
      _setLoading(false);
    } catch (e) {
      _setError('Failed to load accounts: $e');
      _setLoading(false);
    }
  }

  Future<bool> createAccount({
    required String userId,
    required String name,
    required AccountType type,
    double initialBalance = 0.0,
    double? interestRate,
    String? description,
  }) async {
    _setLoading(true);
    _clearError();

    try {
      final account = Account(
        id: '', // Will be generated by Supabase
        userId: userId,
        name: name,
        accountNumber: _generateAccountNumber(),
        balance: initialBalance,
        type: type,
        interestRate: interestRate,
        description: description,
        createdAt: DateTime.now(),
      );

      final createdAccount = await _supabaseService.createAccount(account);
      _accounts.add(createdAccount);
      _setLoading(false);
      return true;
    } catch (e) {
      _setError('Failed to create account: $e');
      _setLoading(false);
      return false;
    }
  }

  Future<void> updateAccountBalance(String accountId, double newBalance) async {
    try {
      await _supabaseService.updateAccountBalance(accountId, newBalance);
      
      // Update local state
      final accountIndex = _accounts.indexWhere((account) => account.id == accountId);
      if (accountIndex != -1) {
        _accounts[accountIndex] = Account(
          id: _accounts[accountIndex].id,
          userId: _accounts[accountIndex].userId,
          name: _accounts[accountIndex].name,
          accountNumber: _accounts[accountIndex].accountNumber,
          balance: newBalance,
          type: _accounts[accountIndex].type,
          interestRate: _accounts[accountIndex].interestRate,
          openDate: _accounts[accountIndex].openDate,
          description: _accounts[accountIndex].description,
          isActive: _accounts[accountIndex].isActive,
          createdAt: _accounts[accountIndex].createdAt,
          updatedAt: DateTime.now(),
        );
        notifyListeners();
      }
    } catch (e) {
      _setError('Failed to update account balance: $e');
    }
  }

  Account? getAccountById(String accountId) {
    try {
      return _accounts.firstWhere((account) => account.id == accountId);
    } catch (e) {
      return null;
    }
  }

  List<Account> getAccountsByType(AccountType type) {
    return _accounts.where((account) => account.type == type).toList();
  }

  String _generateAccountNumber() {
    // Generate a random 10-digit account number
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    return timestamp.toString().substring(timestamp.toString().length - 10);
  }

  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }

  void _setError(String error) {
    _errorMessage = error;
    notifyListeners();
  }

  void _clearError() {
    _errorMessage = null;
    notifyListeners();
  }
}
